using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Prizes.Api.Mapping;
using Prizes.DTO;
using Prizes.Model;
using Prizes.Repository;

namespace Prizes.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class PrizeController : PrizesAppControllerBase
    {
        private readonly IPrizeRepository _prizeRepository;

        public PrizeController(IMappingEngine mappingEngine, ILogger<PrizesAppControllerBase> logger, IPrizeRepository prizeRepository) : base(mappingEngine, logger)
        {
            this._prizeRepository = prizeRepository;
        }

        [HttpPost]
        public async Task<ActionResult> BulkInsertPrizesAsync(PrizeBulkCreationRequest request)
        {

            // there are so many ways we can handle this:
            // * Queue
            // * Kafka
            // * etc
            //for the moment it will go with a simple range add
            var listOfPrizes = new List<DTO.Prize>();
            for (int i = 0; i < request.TotalPrizes; i++)
            {
                var p = new DTO.Prize
                {
                    //id is autogenerated
                    Amount = request.DistributionPerPrize,
                    Name = $"Name = {i}",
                    CustomerId = request.CustomerId,
                    PrizeStatus = StatusEnum.NOT_INITIALIZED.ToString()
                };

                listOfPrizes.Add(p);

            }

            await _prizeRepository.BulkInsertPrizes(listOfPrizes);

            return Ok();

            //it really shoud return Accepted() if we ever move this to a queue or kafka.
            /*
            https://tools.ietf.org/html/rfc7231#section-6.3.3            
            
            The 202 (Accepted) status code indicates that the request has been
            accepted for processing, but the processing has not been completed.
            The request might or might not eventually be acted upon, as it might
            be disallowed when processing actually takes place.  There is no
            facility in HTTP for re-sending a status code from an asynchronous
            operation.
             */

        }


        [HttpGet]
        public ActionResult<List<Models.Prize>> Get()
        {
            var result = _mappingEngine.Map<IEnumerable<Prizes.DTO.Prize>, List<Models.Prize>>(this._prizeRepository.GetPrizes());
            return result;
        }

        // POST api/values
        // [HttpPut]
        // public ActionResult SetStatus([FromBody] PrizeStatusUpdateRequest prize)
        // {
        //     ActionResult operationResult;
        //     var currentPrize = this._prizeRepository.GetPrize(prize.Id);
        //     switch (prize.NewStatus)
        //     {
        //         case Status.Available:
        //             if (currentPrize.Status == Status.Unavailable)
        //             {
        //                 currentPrize.Status = Status.Available;
        //             }
        //             //If the current status is 'Unavailable' all good,
        //             //else we are getting a hack to reenable a promotion or something different.
        //             operationResult = Forbid();
        //             return operationResult;
        //             break;
        //         case Status.Missed:
        //             //Doesn't matter the previous status. We need to disable the promotion
        //             // provided the time differente has been set 
        //             currentPrize.Status = Status.Missed;
        //             break;
        //         case Status.Unavailable:
        //             break;
        //         case Status.Unknown:
        //             break;

        //     }

        //     //then mark it as available


        // }

    }
}
